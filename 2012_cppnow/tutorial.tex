\section{Tutorial}

\begin{frame}
  \tableofcontents[currentsection] 
\end{frame}


\begin{frame}[fragile]

\centerline{\bf Example -- Pendulum}

\begin{minipage}{0.35\textwidth}
    \includegraphics[draft=false,width=1.0\textwidth]{pendulum.pdf}
\end{minipage}
\hspace{2ex}
\begin{minipage}{0.5\textwidth}
 \only<1>{
 Pendulum -- Newtons law

 
 $m a = F$

 Acceleration

 $a = l \ddot{\varphi}$

 Force

 $F=F_N = - m g \sin \varphi$

 Result in an ode for the angle

 $\ddot{\varphi} = - g / l \sin \varphi $
 }

 \only<2>
 {

 $\ddot{\varphi} = - g / l \sin \varphi $

 Small angle $\sin \varphi \approx \phi$

 Harmonic oscillator

 $\ddot{\varphi} = - g / l \varphi$

 An analytic solution is known

 $\varphi = A \cos \omega t + B \sin \omega t$

 Amplitude $A$ and $B$ must be determined from initial conditions:

 $\varphi(t=0) = \varphi_0$, $\dot{\varphi}(t=0) = \dot{\varphi}_0$

 $B=\varphi_0$, $A=\dot{\varphi}_0 / \omega$

 }

 \only<3>{

 Full equation $\ddot{\varphi} = g / l \sin \varphi $

 has also analytic solution Jacobi elliptic function

 Lets enhance the ODE, add friction and external driving

 $\ddot{\varphi} = g / l \sin \varphi - \mu \dot{\varphi} + \varepsilon \sin \omega t $

 No analytic solution is known. We need to solve this equation numerically.

 }

 \only<4>{

 $\ddot{\varphi} = g / l \sin \varphi - \mu \dot{\varphi} + \varepsilon \sin \omega t $

 Create a first order ODE

 $x_1 = \varphi$, $x_2 = \dot{\varphi}$

 $\dot{x_1} = x_2$, $\dot{x_2} = - g / l \sin x_1 - \mu x_2 + \varepsilon \sin \omega t$

 $x_1$ and $x_2$ are the state space variables.

 }
 
\end{minipage}

 
\end{frame}


\begin{frame}[fragile]

\centerline{ \Large Let's solve the pendulum example numerically}


\begin{lstlisting}
#include <boost/numeric/odeint.hpp>

namespace odeint = boost::numeric::odeint;
\end{lstlisting}

$\dot{x_1} = x_2$, $\dot{x_2} = - g / l \sin x_1 - \mu x_2 + \varepsilon \sin \omega t$
\begin{lstlisting}
typedef std::array<double,2> state_type;
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]

\centerline{ \Large Let's solve the pendulum example numerically}

$\dot{x_1} = x_2$, $\dot{x_2} = - g / l \sin x_1 - \mu x_2 + \varepsilon \sin \omega t$
\begin{lstlisting}
struct pendulum
{
  double m_mu , m_omega , m_epsilon;

  pendulum( double mu , double omega , double epsilon )
  : m_mu( mu ) , m_omega( omega ) , m_epsilon( epsilon ) { }

  void operator()( const state_type &x , state_type &dxdt , double t ) const
  {
    dxdt[0] = x[1];
    dxdt[1] = - sin( x[0] ) - m_mu * x[1] + m_epsilon * sin( m_omega * t );
  }
};
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
 \centerline{ \Large Let's solve the pendulum example numerically}

$\varphi(0) = 1$, $\dot{\varphi}(0) = 0$

\begin{lstlisting}
odeint::rk4< state_type > rk4;
pendulum p( 0.1 , 1.05 , 1.5 );

state_type x = {{ 1.0 , 0.0 }};
double t = 0.0;

const double dt = 0.01;
rk4.do_step( p , x , t , dt );
t += dt;
\end{lstlisting}

$x(0) \mapsto x(\Delta t)$

\begin{lstlisting}
std::cout << t << " " << x[0] << " " << x[1] << "\n";
for( size_t i=0 ; i<10 ; ++i )
{
  rk4.do_step( p , x , t , dt );
  t += dt;
  std::cout << t << " " << x[0] << " " << x[1] << "\n";
}
\end{lstlisting}

$x(0) \mapsto x(\Delta t) \mapsto x(2\Delta t) \mapsto x(3\Delta) \mapsto \dots$

\end{frame}


\begin{frame}[fragile]
 Simulation

 $\mu=0$, $\omega_E = 0$, $\varepsilon=0$

 $\mu=0.1$, $\omega_E = 0$, $\varepsilon=0$

 $\mu=0.1$, $\omega_E = 1.05$, $\varepsilon=1.5$
\end{frame}

\begin{frame}[fragile]

  Steppers
  \begin{lstlisting}
odeint::runge_kutta_fehlberg78< state_type > stepper;
  \end{lstlisting}

  \begin{lstlisting}
odeint::runge_kutta_dopri5< state_type > stepper;
  \end{lstlisting}

  but controlled steppers are much better

\end{frame}


\begin{frame}[fragile]
 Controlled steppers

 insert graphic

 \begin{lstlisting}
auto stepper = make_controlled( 1.0e-6 , 1.0e6 ,  odeint::runge_kutta_fehlberg78< state_type >() );
odeint::controlled_step_result res = stepper.try_step( p , x , t , dt );
 \end{lstlisting}

 tries to perform the step and updates $x$, $t$, and $dt$

 it works because runge kutta fehlberg has error estimation

\end{frame}


\begin{frame}[fragile]

Controlled steppers

\begin{lstlisting}
auto stepper = make_controlled( 1.0e-6 , 1.0e6 ,  odeint::runge_kutta_fehlberg78< state_type >() );
while( t < t_end )
{
  odeint::controlled_step_result res = stepper.try_step( p , x , t , dt );
  while( res != odeint::success )
  {
    res = stepper.try_step( p , x , t , dt );
  }
}
\end{lstlisting}

Use integrate functions

\begin{lstlisting}
integrate_adaptive( stepper , x , p , t_start , t_end , dt ); 
integrate_adaptive( stepper , x , p , t_start , t_end , dt , observer );
\end{lstlisting}

\begin{lstlisting}
integrate_adaptive( stepper , p , x , t_start , t_end , dt ,
  std::cout << arg2 << "\t" << arg1[0] << "\t" << arg1[1] << "\n" );
\end{lstlisting}

integrate\_const, integrate\_times, \dots

\end{frame}



\begin{frame}[fragile]

\begin{lstlisting}
integrate_const( stepper , p , x , t , dt , observer );
\end{lstlisting}

problem with controlled stepper

\begin{lstlisting}
integrate_const( make_dense_output( 1.0e-6 , 1.0e-6 , runge_kutta_dopri5< state_type >() ) , p , x , t , dt );
\end{lstlisting}


\end{frame}




\begin{frame}
 More steppers

 implicit, symplectic, predictor-corrector, multistep-methods

 maybe small table
\end{frame}




\begin{frame}
 small summary (kann vielleicht auch wieder weg)
 \begin{itemize}
  \item Very easy example -- harmonic oscillator
  \item Basic features of odeint
  \item Different stepper
  \item Controlled steppers
  \item Dense output steppers
  \item integrate functions
 \end{itemize}

 Now, advanced features

\end{frame}



\begin{frame}
 \slideheading{extended systems}

 \begin{itemize}
  \item<1->Lattice systems
  \item<2->Discretizations of PDEs
  \item<3->ODEs on Graphs
  \item<4->granular systems
 \end{itemize}

 High-Performance-Computing

 zu jedem Punkt ein Bildchen
 
\end{frame}



\begin{frame}
 \slideheading{Phase oscillator lattices} 

 Any oscillator can be described by one variable, its phase.

 (Bild aus phd Talk)

 Trivial dynamics: $\dot{\varphi}=\omega \varphi$

\end{frame}




\begin{frame}
 \slideheading{Phase oscillator lattices} 

 Coupled phase oscillators

 Neurosciences

 Heart dynamics

 Synchronization

 Any weakly perturbed oscillator system

 $\dot{\varphi}_k = \omega_k \varphi_k + q( \varphi_{k+1} , \varphi_k ) + q( \varphi_k , \varphi_{k-1} )$

\end{frame}




\begin{frame}[fragile]
 
 Phase compacton lattices

 $\dot{\varphi}_k = \cos \varphi_{k+1} - \cos \varphi_{k-1}$

 state space contains $N$ variables

 \begin{lstlisting}
typedef std::vector<double> state_type;
 \end{lstlisting}

 Animation with compactons and chaos

 space-time plot for visualization of compactons and chaos

\end{frame}





\begin{frame}[fragile]

Dissipative phase lattice

$\dot{\varphi}_k = \omega_k + \sum\limits_l \sin( \varphi_l - \varphi_k )$

Synchronization

Synchronized state $\varphi_k = \omega_S t + \varphi_{0,k} $

\end{frame}









\begin{frame}
 More advanced features, die themen k√∂nnen auch auf mehreren folien zusammengefasst werden
\end{frame}


\begin{frame}
 Boost::ref
\end{frame}

\begin{frame}
 boost::range
\end{frame}

\begin{frame}
 complex state types, vielleicht auch nicht
\end{frame}

\begin{frame}
 arbitrary precision types
\end{frame}

\begin{frame}
 matrices as state types
\end{frame}

\begin{frame}
 graph as state types
\end{frame}

\begin{frame}
 self expanding lattices
\end{frame}








